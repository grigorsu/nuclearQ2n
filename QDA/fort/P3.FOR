      SUBROUTINE D01AKF(F, A, B, EPSABS, EPSREL, RESULT, ABSERR,WORK,
     * LWORK, IWORK, LIWORK, IFAIL)
C     MARK 8 RELEASE. NAG COPYRIGHT 1980
C
C     D01AKF IS AN ADAPTIVE INTEGRATOR, ESPECIALLY SUITED TO
C     STRONGLY OSCILLATORY NON-SINGULAR INTEGRANDS, WHICH CALCULATES
C     AN APPROXIMATION TO THE INTEGRAL OF A FUNCTION OVER A FINITE
C     INTERVAL (A,B)
C
C     D01AKF ITSELF IS ESSENTIALLY A DUMMY ROUTINE WHOSE FUNCTION IS TO
C     PARTITION THE WORK ARRAYS WORK AND IWORK FOR USE BY D01AKV.
C     WORK IS PARTITIONED INTO 4 ARRAYS EACH OF SIZE LWORK/4.
C     IWORK IS A SINGLE ARRAY IN D01AKV.
C
C     .. SCALAR ARGUMENTS ..
      DOUBLE PRECISION A, ABSERR, B, EPSABS, EPSREL, RESULT
      INTEGER IFAIL, LIWORK, LWORK
C     .. ARRAY ARGUMENTS ..
      DOUBLE PRECISION WORK(LWORK)
      INTEGER IWORK(LIWORK)
C     .. FUNCTION ARGUMENTS ..
      DOUBLE PRECISION F
C     ..
C     .. LOCAL SCALARS ..
C$P 1
C      DOUBLE PRECISION SRNAME
      CHARACTER*8 SRNAME
      INTEGER IBL, IEL, IER, IRL, LIMIT
C     .. FUNCTION REFERENCES ..
      INTEGER P01AAF
C     .. SUBROUTINE REFERENCES ..
C     D01AKV
C     ..
      EXTERNAL F
      DATA SRNAME / 'D01AKF' /
C     CHECK THAT MINIMUM WORKSPACE REQUIREMENTS ARE MET
      IF (LWORK.LT.4) GO TO 20
      IF (LIWORK.LT.LWORK/8+2) GO TO 20
C     LIMIT = UPPER BOUND ON NUMBER OF SUBINTERVALS
      LIMIT = LWORK/4
C     SET UP BASE ADDRESSES FOR WORK ARRAYS
      IBL = LIMIT + 1
      IEL = LIMIT + IBL
      IRL = LIMIT + IEL
C     PERFORM INTEGRATION
      CALL D01AKV(F, A, B, DABS(EPSABS), DABS(EPSREL), WORK(1),WORK(IBL)
     *, WORK(IEL), WORK(IRL), LIMIT, IWORK, LIWORK,RESULT, ABSERR, IER)
      IF (IER.NE.0) GO TO 40
      IFAIL = 0
      GO TO 60
C     ERROR 4 = INSUFFICIENT WORKSPACE
   20 IER = 4
   40 IFAIL = P01AAF(IFAIL,IER,SRNAME)
   60 RETURN
      END
C----------------------------------------------------------------------
      SUBROUTINE D01AJX(LIMIT, LAST, MAXERR, ERMAX, ELIST, IORD,LIORD,
     * NRMAX)
C     MARK 8 RELEASE. NAG COPYRIGHT 1979
C     BASED ON QUADPACK ROUTINE ORDER
C     ******************************************************
C
C           PURPOSE
C              THIS ROUTINE MAINTAINS THE DESCENDING ORDERING
C              IN THE LIST OF THE LOCAL ERROR ESTIMATES
C              RESULTING FROM THE INTERVAL SUBDIVISION
C              PROCESS. AT EACH CALL TWO ERROR ESTIMATES
C              ARE INSERTED USING THE SEQUENTIAL SEARCH
C              METHOD . TOP-DOWN FOR THE LARGEST ERROR
C              ESTIMATE,  BOTTOM-UP FOR THE SMALLEST ERROR
C              ESTIMATE.
C
C           CALLING SEQUENCE
C              CALL D01AJX
C              (LIMIT,LAST,MAXERR,ERMAX,ELIST,IORD,LIORD,NRMAX)
C
C             PARAMETERS (MEANING AT OUTPUT)
C              LIMIT  - MAXIMUM NUMBER OF ERROR ESTIMATES THE LIST
C                       CAN CONTAIN
C
C              LAST   - NUMBER OF ERROR ESTIMATES CURRENTLY
C                       IN THE LIST. ELIST(LAST) CONTAINS
C                       THE SMALLEST ERROR ESTIMATE.
C
C              MAXERR - MAXERR POINTS TO THE NRMAX-TH LARGEST ERROR
C                       ESTIMATE CURRENTLY IN THE LIST.
C
C              ERMAX  - NRMAX-TH LARGEST ERROR ESTIMATE
C                       ERMAX = ELIST(MAXERR)
C
C              ELIST  - ARRAY OF DIMENSION LAST CONTAINING
C                       THE ERROR ESTIMATES
C
C              IORD   - ARRAY CONTAINING POINTERS TO ELIST SO
C                       THAT IORD(1) POINTS TO THE LARGEST
C                       ERROR ESTIMATE,...,IORD(LAST) TO THE
C                       SMALLEST ERROR ESTIMATE
C
C              LIORD  - DIMENSION OF IORD
C
C              NRMAX  - MAXERR = IORD(NRMAX)
C
C     ******************************************************
C
C     .. SCALAR ARGUMENTS ..
      DOUBLE PRECISION ERMAX
      INTEGER LAST, LIMIT, LIORD, MAXERR, NRMAX
C     .. ARRAY ARGUMENTS ..
      DOUBLE PRECISION ELIST(LAST)
      INTEGER IORD(LIORD)
C     ..
C     .. SCALARS IN COMMON ..
      INTEGER JUPBND
C     ..
C     .. LOCAL SCALARS ..
      DOUBLE PRECISION ERRMAX, ERRMIN
      INTEGER I, IBEG, IDO, ISUCC, J, JBND, K
C     ..
      COMMON /AD01AJ/ JUPBND
C
C            CHECK WHETHER THE LIST CONTAINS MORE THAN
C            TWO ERROR ESTIMATES
C
      IF (LAST.GT.2) GO TO 20
      IORD(1) = 1
      IORD(2) = 2
      GO TO 180
C
C           THIS PART OF THE ROUTINE IS ONLY EXECUTED
C           IF, DUE TO A DIFFICULT INTEGRAND, SUBDIVISION
C           INCREASED THE ERROR ESTIMATE. IN THE NORMAL CASE
C           THE INSERT PROCEDURE SHOULD START AFTER THE
C           NRMAX-TH LARGEST ERROR ESTIMATE.
C
   20 ERRMAX = ELIST(MAXERR)
      IF (NRMAX.EQ.1) GO TO 60
      IDO = NRMAX - 1
      DO 40 I=1,IDO
         ISUCC = IORD(NRMAX-1)
         IF (ERRMAX.LE.ELIST(ISUCC)) GO TO 60
         IORD(NRMAX) = ISUCC
         NRMAX = NRMAX - 1
   40 CONTINUE
C
C           COMPUTE THE NUMBER OF ELEMENTS IN THE LIST TO
C           BE MAINTAINED IN DESCENDING ORDER. THIS NUMBER
C           DEPENDS ON THE NUMBER OF SUBDIVISIONS STILL
C           ALLOWED
C
   60 JUPBND = LAST
      IF (LAST.GT.(LIMIT/2+2)) JUPBND = LIMIT + 3 - LAST
      ERRMIN = ELIST(LAST)
C
C           INSERT ERRMAX BY TRAVERSING THE LIST TOP-DOWN
C           STARTING COMPARISON FROM THE ELEMENT
C           ELIST(IORD(NRMAX+1))
C
      JBND = JUPBND - 1
      IBEG = NRMAX + 1
      IF (IBEG.GT.JBND) GO TO 100
      DO 80 I=IBEG,JBND
         ISUCC = IORD(I)
         IF (ERRMAX.GE.ELIST(ISUCC)) GO TO 120
         IORD(I-1) = ISUCC
   80 CONTINUE
  100 IORD(JBND) = MAXERR
      IORD(JUPBND) = LAST
      GO TO 180
C
C           INSERT ERRMIN BY TRAVERSING THE LIST BOTTOM-UP
C
  120 IORD(I-1) = MAXERR
      K = JBND
      DO 140 J=I,JBND
         ISUCC = IORD(K)
         IF (ERRMIN.LT.ELIST(ISUCC)) GO TO 160
         IORD(K+1) = ISUCC
         K = K - 1
  140 CONTINUE
      IORD(I) = LAST
      GO TO 180
  160 IORD(K+1) = LAST
C
C           SET MAXERR AND ERMAX
C
  180 MAXERR = IORD(NRMAX)
      ERMAX = ELIST(MAXERR)
      RETURN
      END
C----------------------------------------------------------------------
      SUBROUTINE D01AKV(F, A, B, EPSABS, EPSREL, ALIST, BLIST,ELIST,
     * RLIST, LIMIT, IORD, LIORD, RESULT, ABSERR, IER)
C     MARK 8 RELEASE. NAG COPYRIGHT 1979
C     BASED ON QUADPACK ROUTINE DQAG (FORMERLY QAG)
C     **********************************************************
C
C        PURPOSE
C           THE ROUTINE CALCULATES AN APPROXIMATION
C           /RESULT/ TO A GIVEN DEFINITE INTEGRAL   I =
C           INTEGRAL OF /F/ OVER (A,B), HOPEFULLY
C           SATISFYING FOLLOWING CLAIM FOR ACCURACY .
C           ABS(I-RESULT) .LE. MAX(EPSABS,EPSREL*ABS(I)).
C
C          CALLING SEQUENCE
C           CALL D01AKV (F,A,B,EPSABS,EPSREL,
C                        ALIST,BLIST,ELIST,RLIST,LIMIT,IORD,LIORD,
C                        RESULT,ABSERR,IER)
C
C        PARAMETERS
C            F      - FUNCTION SUBPROGRAM DEFINING THE INTEGRAND
C                     FUNCTION F(X). THE ACTUAL NAME FOR F
C                     NEEDS TO BE DECLARED E X T E R N A L
C                     IN THE DRIVER PROGRAM
C
C            A      - LOWER LIMIT OF INTEGRATION
C
C            B      - UPPER LIMIT OF INTEGRATION
C
C            EPSABS - ABSOLUTE ACCURACY REQUESTED
C
C            EPSREL - RELATIVE ACCURACY REQUESTED
C                     IF EPSABS .LE. 0 AND EPSREL .LE. 0 THE ROUTINE
C                     WILL END WITH IER  = 0
C
C
C            ALIST,BLIST,ELIST,RLIST
C                   - WORK ARRAYS (FUNCTIONS DESCRIBED BELOW)
C
C            LIMIT  - UPPER BOUND FOR NUMBER OF SUBINTERVALS
C
C            IORD   - WORK ARRAY
C
C            LIORD  - LENGTH OF IORD (AT LEAST LIMIT/2 + 2)
C
C            RESULT - APPROXIMATION TO THE INTEGRAL
C
C            ABSERR - ESTIMATE OF THE MODULUS OF THE ABSOLUTE ERROR,
C                     WHICH SHOULD EQUAL OR EXCEED ABS(I-RESULT)
C
C            IER    - IER   = 0 NORMAL AND RELIABLE
C                             TERMINATION OF THE ROUTINE.
C                             IT IS ASSUMED THAT THE
C                             REQUESTED  ACCURACY HAS BEEN
C                             ACHIEVED.
C                   - IER   .NE. 0 ABNORMAL TERMINATION OF
C                             THE ROUTINE. THE ESTIMATES
C                             FOR RESULT AND ERROR ARE LESS
C                             RELIABLE. IT IS ASSUMED THAT
C                             THE  REQUESTED ACCURACY HAS
C                             NOT BEEN ACHIEVED.
C                         = 1 MAXIMUM NUMBER OF SUBDIVISIONS ALLOWED
C                             HAS BEEN ACHIEVED.THE USER CAN ALLOW MORE
C                             SUBDIVISIONS BY INCREASING
C                             THE DIMENSIONS OF WORK ARRAYS
C                             WORK AND LWORK.
C                             HOWEVER, THIS MAY YIELD NO
C                             IMPROVEMENT, AND IT IS RATHER
C                             ADVISED TO  HAVE A CLOSE LOOK
C                             AT THE INTEGRAND IN ORDER TO
C                             DETERMINE THE INTEGRATION
C                             DIFFICULTIES. IF THE POSITION
C                             OF A LOCAL  DIFFICULTY CAN BE
C                             DETERMINED (I.E. SINGULARITY,
C                             DISCONTINUITY WITHIN THE
C                             INTERVAL) ONE WILL PROBABLY
C                             GAIN FROM  SPLITTING UP THE
C                             INTERVAL AT THIS POINT AND
C                             CALLING THE INTEGRATOR ON THE
C                             SUBRANGES. IF POSSIBLE, AN
C                             APPROPRIATE  SPECIAL-PURPOSE
C                             INTEGRATOR SHOULD BE USED
C                             WHICH IS DESIGNED FOR
C                             HANDLING THE TYPE OF
C                             DIFFICULTY INVOLVED.
C                         = 2 THE OCCURRENCE OF ROUNDOFF ERROR IS
C                             DETECTED WHICH PREVENTS THE REQUESTED
C                             TOLERANCE FROM BEING ACHIEVED.
C                         = 3 EXTREMELY BAD INTEGRAND
C                             BEHAVIOUR OCCURS AT SOME
C                             INTERIOR POINTS OF THE
C                             INTEGRATION INTERVAL.
C
C     **********************************************************
C     .. SCALAR ARGUMENTS ..
      DOUBLE PRECISION A, ABSERR, B, EPSABS, EPSREL, RESULT
      INTEGER IER, LIMIT, LIORD
C     .. ARRAY ARGUMENTS ..
      DOUBLE PRECISION ALIST(LIMIT), BLIST(LIMIT), ELIST(LIMIT),
     * RLIST(LIMIT)
      INTEGER IORD(LIORD)
C     .. FUNCTION ARGUMENTS ..
      DOUBLE PRECISION F
C     ..
C     .. LOCAL SCALARS ..
      DOUBLE PRECISION A1, A2, AREA12, AREA1, AREA2, AREA, B1, B2,
     * DEFAB1,DEFAB2, DEFABS, EPMACH, ERRBND, ERRMAX, ERRO12, ERROR1,
     *ERROR2, ERRSUM, RESABS, UFLOW
      INTEGER IROFF1, IROFF2, K, LAST1, LAST, MAXERR, NRMAX
C     .. FUNCTION REFERENCES ..
      DOUBLE PRECISION X02AAF, X02ABF
C     .. SUBROUTINE REFERENCES ..
C     D01AJX, D01AKZ
C     ..
      EXTERNAL F
      EPMACH = X02AAF(1.0D0)
      UFLOW = X02ABF(1.0D0)
      LAST1 = 1
C
C            LIST OF MAJOR VARIABLES
C            -----------------------
C
C           ALIST     - LIST OF LEFT END POINTS OF ALL SUBINTERVALS
C                       CONSIDERED UP TO NOW
C           BLIST     - LIST OF RIGHT END POINTS OF ALL SUBINTERVALS
C                       CONSIDERED UP TO NOW
C           RLIST(I)  - APPROXIMATION TO THE INTEGRAL OVER
C                       (ALIST(I),BLIST(I))
C           ELIST(I)  - ERROR ESTIMATE APPLYING TO RLIST(I)
C           MAXERR    - POINTER TO THE INTERVAL WITH LARGEST
C                       ERROR ESTIMATE
C           ERRMAX    - ELIST(MAXERR)
C           AREA      - SUM OF THE INTEGRALS OVER THE SUBINTERVALS
C           ERRSUM    - SUM OF THE ERRORS OVER THE SUBINTERVALS
C           ERRBND    - REQUESTED ACCURACY MAX(EPSABS,EPSREL*
C                       ABS(RESULT))
C           *****1    - VARIABLE FOR THE LEFT INTERVAL
C           *****2    - VARIABLE FOR THE RIGHT INTERVAL
C           LAST      - INDEX FOR SUBDIVISION
C
C           FIRST APPROXIMATION TO THE INTEGRAL
C           -----------------------------------
C
      IER = 0
      CALL D01AKZ(F, A, B, RESULT, ABSERR, DEFABS, RESABS)
C
C           TEST ON ACCURACY
C
      ERRBND = DMAX1(EPSABS,EPSREL*DABS(RESULT))
      IF (ABSERR.LE.0.5D+02*EPMACH*DEFABS .AND. ABSERR.GT.ERRBND)IER = 2
      IF (LIMIT.LT.2 .AND. ABSERR.GT.ERRBND) IER = 1
      IF (IER.NE.0 .OR. ABSERR.LE.ERRBND) GO TO 140
C
C           INITIALIZATION
C           --------------
C
C
      ALIST(1) = A
      BLIST(1) = B
      RLIST(1) = RESULT
      ERRMAX = ABSERR
      MAXERR = 1
      AREA = RESULT
      ERRSUM = ABSERR
      NRMAX = 1
      IROFF1 = 0
      IROFF2 = 0
C
C           MAIN DO-LOOP
C           -----------
C
      IF (LIMIT.LT.2) GO TO 100
      DO 80 LAST=2,LIMIT
         LAST1 = LAST
C
C           BISECT THE SUBINTERVAL WITH THE LARGEST ERROR ESTIMATE
C
         A1 = ALIST(MAXERR)
         B1 = 0.5D+00*(ALIST(MAXERR)+BLIST(MAXERR))
         A2 = B1
         B2 = BLIST(MAXERR)
         CALL D01AKZ(F, A1, B1, AREA1, ERROR1, RESABS, DEFAB1)
         CALL D01AKZ(F, A2, B2, AREA2, ERROR2, RESABS, DEFAB2)
C
C           IMPROVE PREVIOUS APPROXIMATION OF INTEGRAL
C           AND ERROR AND TEST FOR ACCURACY
C
         AREA12 = AREA1 + AREA2
         ERRO12 = ERROR1 + ERROR2
         ERRSUM = ERRSUM + ERRO12 - ERRMAX
         AREA = AREA + AREA12 - RLIST(MAXERR)
         IF (DEFAB1.EQ.ERROR1 .OR. DEFAB2.EQ.ERROR2) GO TO 20
         IF (DABS(RLIST(MAXERR)-AREA12).LE.0.1D-04*DABS(AREA12) .AND.
     *   ERRO12.GE.0.99D+00*ERRMAX) IROFF1 = IROFF1 + 1
         IF (LAST.GT.10 .AND. ERRO12.GT.ERRMAX) IROFF2 = IROFF2 + 1
   20    RLIST(MAXERR) = AREA1
         RLIST(LAST) = AREA2
         ERRBND = DMAX1(EPSABS,EPSREL*DABS(AREA))
         IF (ERRSUM.LE.ERRBND) GO TO 100
C
C           TEST FOR ROUNDOFF ERROR AND EVENTUALLY
C           SET ERROR FLAG
C
         IF (IROFF1.GE.6 .OR. IROFF2.GE.20) IER = 2
C
C           SET ERROR FLAG IN THE CASE THAT THE NUMBER OF INTERVAL
C           BISECTIONS EXCEEDS /LIMIT/
C
         IF (LAST.EQ.LIMIT) IER = 1
C
C           SET ERROR FLAG IN THE CASE OF BAD INTEGRAND BEHAVIOUR
C           AT INTERIOR POINTS OF INTEGRATION RANGE
C
         IF (DMAX1(DABS(A1),DABS(B2)).LE.(0.1D+01+0.1D+03*EPMACH)*
     *   (DABS(A2)+0.1D+04*UFLOW)) IER = 3
         IF (IER.NE.0) GO TO 100
C
C           APPEND THE NEWLY-CREATED INTERVALS TO THE LIST
C           ----------------------------------------------
C
         IF (ERROR2.GT.ERROR1) GO TO 40
         ALIST(LAST) = A2
         BLIST(MAXERR) = B1
         BLIST(LAST) = B2
         ELIST(MAXERR) = ERROR1
         ELIST(LAST) = ERROR2
         GO TO 60
   40    ALIST(MAXERR) = A2
         ALIST(LAST) = A1
         BLIST(LAST) = B1
         RLIST(MAXERR) = AREA2
         RLIST(LAST) = AREA1
         ELIST(MAXERR) = ERROR2
         ELIST(LAST) = ERROR1
C
C           CALL SUBROUTINE D01AJX TO MAINTAIN THE
C           DESCENDING ORDERING IN THE LIST OF ERROR
C           ESTIMATES AND SELECT THE SUBINTERVAL WITH THE
C           LARGEST ERROR ESTIMATE (TO BE BISECTED NEXT)
C
   60    CALL D01AJX(LIMIT, LAST, MAXERR, ERRMAX, ELIST, IORD,LIORD,
     *    NRMAX)
   80 CONTINUE
C
C           COMPUTE FINAL RESULT
C           --------------------
C
  100 RESULT = 0.D+00
      DO 120 K=1,LAST
         RESULT = RESULT + RLIST(K)
  120 CONTINUE
      ABSERR = ERRSUM
  140 IORD(1) = 4*LAST1
      RETURN
      END
C--------------------------------------------------------------------
      SUBROUTINE D01AKZ(F, A, B, RESULT, ABSERR, RESABS, RESASC)
C     MARK 8 RELEASE. NAG COPYRIGHT 1979
C     BASED ON QUADPACK ROUTINE GRK61
C     ***********************************************************
C
C        PURPOSE
C           TO COMPUTE I = INTEGRAL OF F OVER (A,B), WITH ERROR
C                          ESTIMATE
C                      J = INTEGRAL OF ABS(F) OVER (A,B)
C
C        CALLING SEQUENCE
C           CALL D01AKZ (F,A,B,RESULT,ABSERR,RESABS,RESASC)
C
C        PARAMETERS
C           F      - FUNCTION SUBPROGRAM DEFINING THE INTEGRAND
C                    FUNCTION F(X). THE ACTUAL NAME FOR F NEEDS
C                    TO BE DECLARED E X T E R N A L IN THE
C                    CALLING PROGRAM
C
C           A      - LOWER LIMIT OF INTEGRATION
C
C           B      - UPPER LIMIT OF INTEGRATION
C
C           RESULT - APPROXIMATION TO THE INTEGRAL I
C                    RESULT IS CALCULATED BY APPLYING THE 61-POINT
C                    GAUSS-KRONROD RULE (RESK) OBTAINED BY OPTIMAL
C                    ADDITION OF ABSCISSAE TO THE 30-POINT
C                    GAUSS RULE (RESG).
C
C           ABSERR - ESTIMATE OF THE MODULUS OF THE ABSOLUTE ERROR,
C                    WHICH SHOULD EQUAL OR EXCEED ABS(I-RESULT)
C
C           RESABS - APPROXIMATION TO THE INTEGRAL J
C
C           RESASC - APPROXIMATION TO THE INTEGRAL OF ABS(F-I/(B-A))
C
C     ***********************************************************
C
C     .. SCALAR ARGUMENTS ..
      DOUBLE PRECISION A, ABSERR, B, RESABS, RESASC, RESULT
C     .. FUNCTION ARGUMENTS ..
      DOUBLE PRECISION F
C     ..
C     .. LOCAL SCALARS ..
      DOUBLE PRECISION ABSC, CENTRE, DHLGTH, EPMACH, FC, FSUM, FVAL1,
     * FVAL2,HLGTH, RESG, RESK, RESKH, UFLOW
      INTEGER J
C     .. LOCAL ARRAYS ..
      DOUBLE PRECISION FV1(30), FV2(30), WG(30), WGK(31), XGK(31)
C     .. FUNCTION REFERENCES ..
      DOUBLE PRECISION X02AAF, X02ABF
C     ..
C
C            THE ABSCISSAE AND WEIGHTS ARE GIVEN FOR THE
C            INTERVAL (-1,1). BECAUSE OF SYMMETRY ONLY THE POSITIVE
C            ABSCISSAE AND THEIR CORRESPONDING WEIGHTS ARE GIVEN.
C
C            XGK   - ABSCISSAE OF THE 61-POINT GAUSS-KRONROD RULE
C                    XGK(2), XGK(4). ... ABSCISSAE OF THE 30-POINT
C                    GAUSS RULE
C                    XGK(1), XGK(3). ... OPTIMALLY ADDED ABSCISSAE
C                    TO THE 30-POINT GAUSS RULE
C
C            WGK   - WEIGHTS OF THE 61-POINT GAUSS-KRONROD RULE
C
C            WG    - WEIGTHS OF THE 30-POINT GAUSS RULE,
C                    CORRESPONDING TO THE ABSCISSAE XGK(2),
C                    XGK(4), ... WG(1), WG(3), ... ARE SET
C                    TO ZERO
C
      DATA XGK(1), XGK(2), XGK(3), XGK(4), XGK(5), XGK(6), XGK(7),XGK(8)
     *, XGK(9), XGK(10), XGK(11), XGK(12), XGK(13), XGK(14),XGK(15) /
     *0.9994844100504906D+00,
     *0.9968934840746495D+00,
     *0.9916309968704045D+00,
     *0.9836681232797472D+00,
     *0.9731163225011262D+00,
     *0.9600218649683075D+00,
     *0.9443744447485599D+00,
     *0.9262000474292743D+00,
     *0.9055733076999077D+00,
     *0.8825605357920526D+00,
     *0.8572052335460610D+00,
     *0.8295657623827683D+00,
     *0.7997278358218390D+00,
     *0.7677774321048261D+00,
     *0.7337900624532268D+00/
      DATA XGK(16), XGK(17), XGK(18), XGK(19), XGK(20)/
     *0.6978504947933157D+00,
     *0.6600610641266269D+00,
     *0.6205261829892428D+00,
     *0.5793452358263616D+00,
     *0.5366241481420198D+00/
      DATA XGK(21), XGK(22), XGK(23), XGK(24), XGK(25), XGK(26),XGK(27),
     * XGK(28), XGK(29), XGK(30), XGK(31)/
     *0.4924804678617785D+00,
     *0.4470337695380891D+00,
     *0.4004012548303943D+00,
     *0.3527047255308781D+00,
     *0.3040732022736250D+00,
     *0.2546369261678898D+00,
     *0.2045251166823098D+00,
     *0.1538699136085835D+00,
     *0.1028069379667370D+00,
     *0.5147184255531769D-01,0.0D0/
      DATA WGK(1), WGK(2), WGK(3), WGK(4), WGK(5), WGK(6), WGK(7),WGK(8)
     *, WGK(9), WGK(10), WGK(11), WGK(12), WGK(13), WGK(14),WGK(15) /
     *0.1389013698677007D-02,
     *0.3890461127099884D-02,
     *0.6630703915931292D-02,
     *0.9273279659517763D-02,
     *0.1182301525349634D-01,
     *0.1436972950704580D-01,
     *0.1692088918905327D-01,
     *0.1941414119394238D-01,
     *0.2182803582160919D-01,
     *0.2419116207808060D-01,
     *0.2650995488233310D-01,
     *0.2875404876504129D-01,
     *0.3090725756238776D-01,
     *0.3298144705748372D-01,
     *0.3497933802806002D-01/
      DATA WGK(16), WGK(17), WGK(18), WGK(19), WGK(20)/
     *0.3688236465182122D-01,
     *0.3867894562472759D-01,
     *0.4037453895153595D-01,
     *0.4196981021516424D-01,
     *0.4345253970135606D-01/
      DATA WGK(21), WGK(22), WGK(23), WGK(24), WGK(25), WGK(26),WGK(27),
     * WGK(28), WGK(29), WGK(30), WGK(31)/
     *0.4481480013316266D-01,
     *0.4605923827100698D-01,
     *0.4718554656929915D-01,
     *0.4818586175708712D-01,
     *0.4905543455502977D-01,
     *0.4979568342707420D-01,
     *0.5040592140278234D-01,
     *0.5088179589874960D-01,
     *0.5122154784925877D-01,
     *0.5142612853745902D-01,
     *0.5149472942945156D-01/
      DATA WG(1), WG(2), WG(3), WG(4), WG(5), WG(6), WG(7), WG(8),WG(9),
     * WG(10), WG(11), WG(12), WG(13), WG(14), WG(15)/0.0D0,
     *0.7968192496166605D-02,0.0D0,
     *0.1846646831109095D-01,0.0D0,
     *0.2878470788332336D-01,0.0D0,
     *0.3879919256962704D-01,0.0D0,
     *0.4840267283059405D-01,0.0D0,
     *0.5749315621761906D-01,0.0D0,
     *0.6597422988218049D-01,0.0D0/
      DATA WG(16), WG(17), WG(18), WG(19), WG(20)/
     *0.7375597473770520D-01,0.0D0,
     *0.8075589522942021D-01,0.0D0,
     *0.8689978720108297D-01/
      DATA WG(21), WG(22), WG(23), WG(24), WG(25), WG(26), WG(27),WG(28)
     *, WG(29), WG(30) /0.0D0,0.921225222377861D-01,0.0D0,
     *0.9636873717464425D-01,0.0D0,
     *0.9959342058679526D-01,0.0D0,
     *0.1017623897484055D+00,0.0D0,
     *0.1028526528935588D+00/
      EPMACH = X02AAF(1.0D0)
      UFLOW = X02ABF(1.0D0)
C
C           LIST OF MAJOR VARIABLES
C           ------------------------
C           CENTRE - MID-POINT OF THE INTERVAL
C           HLGTH  - HALF-LENGTH OF THE INTERVAL
C           ABSC   - ABSCISSA
C           FVAL*  - FUNCTION VALUE
C           RESG   - 30-POINT GAUSS RULE
C           RESK   - 61-POINT GAUSS-KRONROD RULE
C           RESKH  - APPROXIMATION TO MEAN VALUE OF F
C                    OVER (A,B), I.E. TO I/(B-A)
C
      CENTRE = 0.5D+00*(B+A)
      HLGTH = 0.5D+00*(B-A)
      DHLGTH = DABS(HLGTH)
C
C           COMPUTE THE 61-POINT GAUSS-KRONROD APPROXIMATION TO THE
C           INTEGRAL, AND ESTIMATE THE ABSOLUTE ERROR
C
      RESG = 0.0D+00
      FC = F(CENTRE)
      RESK = WGK(31)*FC
      RESABS = DABS(RESK)
      DO 20 J=1,30
         ABSC = HLGTH*XGK(J)
         FVAL1 = F(CENTRE-ABSC)
         FVAL2 = F(CENTRE+ABSC)
         FV1(J) = FVAL1
         FV2(J) = FVAL2
         FSUM = FVAL1 + FVAL2
         RESG = RESG + WG(J)*FSUM
         RESK = RESK + WGK(J)*FSUM
         RESABS = RESABS + WGK(J)*(DABS(FVAL1)+DABS(FVAL2))
   20 CONTINUE
      RESKH = RESK*0.5D+00
      RESASC = WGK(31)*DABS(FC-RESKH)
      DO 40 J=1,30
         RESASC = RESASC + WGK(J)*(DABS(FV1(J)-RESKH)+DABS(FV2(J)-RESKH)
     *   )
   40 CONTINUE
      RESULT = RESK*HLGTH
      RESABS = RESABS*DHLGTH
      RESASC = RESASC*DHLGTH
      ABSERR = DABS((RESK-RESG)*HLGTH)
      IF (RESASC.NE.0.D0) ABSERR = RESASC*DMIN1(0.1D+01,(0.2D+03*ABSERR/
     *RESASC)**1.5D0)
      IF (RESABS.GT.UFLOW/(0.5D+02*EPMACH)) ABSERR =DMAX1(EPMACH*RESABS*
     *0.5D+02,ABSERR)
      RETURN
      END
      INTEGER FUNCTION P01AAF(IFAIL, ERROR, SRNAME)
C     MARK 1 RELEASE.  NAG COPYRIGHT 1971
C     MARK 3 REVISED
C     MARK 4A REVISED, IER-45
C     MARK 4.5 REVISED
C     MARK 7 REVISED (DEC 1978)
C     RETURNS THE VALUE OF ERROR OR TERMINATES THE PROGRAM.
      INTEGER ERROR, IFAIL, NOUT
C$P 1
      CHARACTER*8 SRNAME
C     TEST IF NO ERROR DETECTED
      IF (ERROR.EQ.0) GO TO 20
C     DETERMINE OUTPUT UNIT FOR MESSAGE
      CALL X04AAF (0,NOUT)
C     TEST FOR SOFT FAILURE
      IF (MOD(IFAIL,10).EQ.1) GO TO 10
C     HARD FAILURE
      WRITE (NOUT,99999) SRNAME, ERROR
C     STOPPING MECHANISM MAY ALSO DIFFER
      STOP
C     SOFT FAIL
C     TEST IF ERROR MESSAGES SUPPRESSED
   10 IF (MOD(IFAIL/10,10).EQ.0) GO TO 20
      WRITE (NOUT,99999) SRNAME, ERROR
   20 P01AAF = ERROR
      RETURN
99999 FORMAT (1H0, 38HERROR DETECTED BY NAG LIBRARY ROUTINE , A8,
     * 11H - IFAIL = , I5//)
      END
C--------------------------------------------------------------
      DOUBLE PRECISION FUNCTION X02AAF(X)
C     NAG COPYRIGHT 1975
C     MARK 4.5 RELEASE
      DOUBLE PRECISION X
C     * EPS *
C
C     IBM DOUBLE PRECISION VERSION
C
C     RETURNS THE VALUE EPS WHERE EPS IS THE SMALLEST
C     POSITIVE
C     NUMBER SUCH THAT 1.0 + EPS > 1.0
C     THE X PARAMETER IS NOT USED
C     FOR ICL 1900
C     X02AAF = 2.0**(-37.0)
C     FOR IBM 360/370
C     X02AAF = 2.0D0**(-52.0D0)
      DOUBLE PRECISION Z
C      DATA Z/Z3410000000000000/
      DATA Z/1.D-18/
      X02AAF = Z
      RETURN
      END
C----------------------------------------------------------------
      DOUBLE PRECISION FUNCTION X02ABF(X)
C     NAG COPYRIGHT 1975
C     MARK 4.5 RELEASE
      DOUBLE PRECISION X
C     * RMIN *
C
C     IBM DOUBLE PRECISION VERSION
C
C     RETURNS THE VALUE OF THE SMALLEST POSITIVE REAL FLOATING-
C     POINT NUMBER EXACTLY REPRESENTABLE ON THE COMPUTER
C     THE X PARAMETER IS NOT USED
C     FOR ICL 1900
C     X02ABF = 2.0**(-257.0)
C     FOR IBM 360/370
C     X02ABF = 16.0D0**(-65.0D0)
      DOUBLE PRECISION Z
C     DATA Z/Z0010000000000000/
      DATA Z/1.D-80/
      X02ABF = Z
      RETURN
      END
C-------------------------------------------------------------------
      SUBROUTINE X04AAF(I,NERR)
C     MARK 7 RELEASE. NAG COPYRIGHT 1978
C     MARK 7C REVISED IER-190 (MAY 1979)
C     IF I = 0, SETS NERR TO CURRENT ERROR MESSAGE UNIT NUMBER
C     (STORED IN NERR1).
C     IF I = 1, CHANGES CURRENT ERROR MESSAGE UNIT NUMBER TO
C     VALUE SPECIFIED BY NERR.
C
C     *** NOTE ***
C     THIS ROUTINE ASSUMES THAT THE VALUE OF NERR1 IS SAVED
C     BETWEEN CALLS.  IN SOME IMPLEMENTATIONS IT MAY BE
C     NECESSARY TO STORE NERR1 IN A LABELLED COMMON
C     BLOCK /AX04AA/ TO ACHIEVE THIS.
C
C     .. SCALAR ARGUMENTS ..
      INTEGER I, NERR
C     ..
C     .. LOCAL SCALARS ..
      INTEGER NERR1
      SAVE NERR1
C     ..
      DATA NERR1 /6/
      IF (I.EQ.0) NERR = NERR1
      IF (I.EQ.1) NERR1 = NERR
      RETURN
      END
C